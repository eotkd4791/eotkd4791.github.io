---
title: "JAVA Network Programming"
categories:
  - Network
  - Java
tags:
  - Network
  - Java
comments:
  - true
---

# 기본 네트워크 개념
## 네트워크
- 네트워크는 실시간으로 서로 데이터를 주고받을 수 있는 컴퓨터 및 다른 장치들의 집합. 네트워크 안의 각각의 장비를 "노드"라고 하고 노드 중에서 일반적인 PC를 "호스트"라고 한다.

- 모든 네트워크 노드는 주소를 가지고 있으며, 주소는 네트워크 종류에 따라 다르게 할당된다.

- 모든 현대의 컴퓨터 네트워크는 패킷 교환(packet-switched) 방식을 사용한다. 패킷은 네트워크를 순환하는 데이터의 덩어리라고 볼 수 있다.

- 패킷 교환 방식의 장점
   1. 단일 회선을 통해 지속적으로 많은 패킷을 교환할 수 있다는 점이고 이러한 특성을 통해 경제적으로 네트워크를 구축할 수 있다.

   2. 간섭없이 같은 선을 공유할 수 있다는 점과 체크섬(checksum)값을 이용하여 전송 중에 발생한 데이터의 손상 여부를 확인할 수 있다.

## TCP/IP-네트워크 계층
- 네트워크에 존재하는 프로토콜 스택에서 각각의 계층은 서로 인접한 계층과 통신한다. 

- 하단의 경우, 환경에 따라 일부 호스트는 이더넷을 사용하고, 일부는 와이파이나 PPP(Point to Point Protocol)을 사용한다.

- 상단 프로토콜의 경우 호스트가 실행 중인 프로그램에 따라 달라진다.

- 특정 네트워크 요구에 따라 구성된 몇몇 다른 계층 모델들이 존재한다. 대표적으로 인터넷에 적합한 표준 TCP/IP 4계층 모델을 사용한다.

- 애플리케이션들은 애플리케이션 계층에서 실행되고 전송계층하고만 통신을 한다. 전송 계층은 위아래로 인접해있는 애플리케이션 계층과 인터넷 계층하고 대화를 한다. 

## TCP/IP-호스트-투-네트워크 계층 (데이터 링크 계층)
- 이더넷 카드나 와이파이 안테나 같은 특정 네트워크 인터페이스가 물리적인 연결을 통해 로컬 네트워크 및 외부로 IP데이터그램을 보내는 방법을 정의한다.

- 이 계층의 일부는 회선, 광케이블, 전파, 연기 신호 같은 하드웨어로 구성되어 있고 다른 컴퓨터와 연결한다. 이러한 특성 때문에 때때로 네트워크 물리 계층이라고도 한다. 자바로는 이 계층과 관련이 적으며 물리 계층을 다룰 수 없다.

## TCP/IP-인터넷 계층
- 어떤 물리적인 연결과 마주하더라도 네트워크 통신을 위해 사용하는 API는 동일하며, 이것을 가능하게 하는 것이 인터넷 계층이다.

- OSI 모델에서는 인터넷 계층은 좀 더 포괄적인 이름의 네트워크 계층으로 불린다. 네트워크 계층 프로토콜은 데이터의 비트와 바이트를 좀 더 큰 그룹인 패킷으로 구성하는 방법과 다른 컴퓨터가 서로를 찾을 수 있도록 주소 체계를 정의한다.

- 인터넷 프로토콜(IP)는 세상에서 가장 널리 사용되는 네트워크 계층 프로토콜이며, 자바가 이해할 수 있는 유일한 네트워크 계층 프로토콜이기도 하다.

- 인터넷 계층을 통해 데이터는 데이터그램이라는 패킷으로 보내진다.

## TCP/IP-전송 계층
- 데이터그램 자체에는 몇 가지 단점이 있는데 데이터그램은 전송이 보장되지 않으며 목적지까지 전송되더라도 전송 중에 손상될 가능성이 있다.

- 헤더에 있는 체크섬은 단지 헤더의 손상만 발견할 수 있을 뿐 데이터그램의 데이터 부분에 대한 손상은 발견할 수 없다. 

- 각각의 데이터 그램은 출발지에서 목적지까지 서로 다른 경로로 전달되기 때문에 항상 전송한 순서대로 목적지에 도달하지는 않는다.

- 전송 계층은 만약 패킷이 손실된다면, 해당 패킷에 대해 송신자에게 재전송을 요창할 수 있다. IP네트워크는 이러한 기능을 각각 데이터그램에 몇몇 정보를 포함하고 있는 부가적인 헤더를 추가한다.

- 전송 계층의 주요 프로토콜
  1. 전송 제어 프로토콜(TCP)은 손실되거나 손상된 데이터의 재전송과 데이터의 순서를 보장하는 오버헤드가 높은 프로토콜이다.
  2. 사용자 데이터그램 프로토콜(UDP)은 수신자가 패킷의 손상을 감지할 수는 있찌만 수신된 패킷의 순서를 보장하지는 않는다.
  - UDP는 종종 TCP보다 빠르며 TCP는 신뢰할 수 있는 프로토콜, UDP는 신뢰할 수 없는 프로토콜이라고 불린다.

## TCP/IP-애플리케이션 계층
- 사용자에게 데이터가 전달되는 계층, 데이터가 전송된 후 해당 데이터로 어떤 일을 할지 결정한다. 

- 용도에 따라 분류된 프로토콜이 있다.
  - 웹을 위한 HTTP
  - 이메일 전송을 위한 SMTP, POP, IMAP 
  - 파일 전송을 위한 FTP, FSP, TFTP 
  - 파일 접근을 위한 NFS
  - 파일 공유를 위한 Gnutella, BitTorrent
  - 음성 통신의 위한 SIP, Skype

## IP, TCP, UDP

- 인터넷 프로토콜 IP는 출발지와 목적지 두 지점 사이의 여러 경로를 허용하고 손상된 라우터 주변 데이터의 패킷을 라우팅할 수 있도록 설계되었다.
  
- 두 지점 사이의 많은 경로 중 가장 빠른 경로는 시간이 지나면서 네트워크 트래픽과 다른 요인에 의해 달라질 수 있기 떄문에 특정 데이터 스트림을 구성하는 패킷들은 모두 같은 경로로 전달되지 않는다.

  - 이러한 IP의 기본 설계 요소들을 개선하기 위해, ___각 연결의 끝에 IP패킷의 수신 여부 확인 기능___ 과   ___손상되거나 손실된 패킷에 대한 재전송 요청 기능___ 을 추가하는 TCP가 IP계층 위에 놓인다. TCP는 패킷들이 보내진 순서와 동일한 순서로 수신 측에서 조립할 수 있게 한다.

- TCP는 오버헤드를 유발한다. 그래서 데이터의 순서가 중요하지 안호 일부 패킷의 손실이 전체 데이터 스트림을 손상시키지 않는 경우, 패킷은 종종 UDP를 이용하는 것이 효율적이다.

- UDP 사용 시 데이터 손실을 고려해야 한다면 애플리케이션 레벨에서 오류정정 코드(error-correcting code)를 UDP 데이터 스트림에 내장할 수 있다.

- 자바는 TCP, UDP만을 지원한다.

<br>
<br>

|프로토콜| 연결방식 | 데이터 경계 구분 | 통신 방식 | 신뢰성 | 전송 순서 보장 | 수신 여부 확인 | 패킷 관리 | 전송 속도| 
|:------:|:------:|:--------:|:------:|:----:|:----:|:----:|:----:|:----:|
|TCP| 연결형 프로토콜(연결 후 통신) |O | 1:1  | O | O | O | 불필요 | UDP보다 느림 |
|UDP| 비연결형 프로토콜(연결 없이 통신) | X | 1:1, 1:N, N:N | X | X | X | 필요 | TCP보다 빠름 |

<br>
<br>


## IP주소와 도메인
- IPv4 : 점으로 구분된 네 개의 숫자 형식으로 표기한다. (4Byte)
  - 각 네개의 숫자는 0~255까지의 부호 없는 바이트 범위의 값을 가질 수 있다.
  - 네트워크에 접속된 모든 컴퓨터는 유일한 4바이트 주소를 가진다. 
  - 데이터가 네트워크를 통해 전송될 떄 패킷의 헤더에는 패킷이 가고자 하는 장비의 주소(목적지 주소)와 패킷을 보낸 주소(출발지 주소)를 포함하고 있다. 
  - 패킷의 전송 경로상에 있는 라우터는 최적의 경로를 선택한다.
  - IPv4에서 사용 가능한 IP가 거의 소진되었다. 이러한 이유로 IPv6로의 전환이 진행중.

- IPv6 : 16진수를 8개의 블록으로 표기하며 각 블록 앞의 0은 이중 콜론으로 대체 가능.

- 사람들이 숫자들을 기억하기 편하게 하기 위해여 숫자로 표기된 인터넷 주소를 호스트네임으로 변환해 주는 DNS(Domain Name System)가 개발 되었다.
- 특정 컴퓨터나 서버들은 고정된 주소를 사용하며 LAN(Local Area Network)이나 무선에 연결된 대부분의 컴퓨터들은 부팅할 떄 마다 DHCP(Dynamic Host Configuration Protocol) 서버에서 제공하는 다른 주소를 할당받음. -> 유동적이다.

- 10.~, 172.16~172.31, 192.168~ 범위 내의 모든 IPv4 주소들은 인터넷 주소로 할당되지 않으며, 이렇게 라우팅이 불가능한 주소는 외부 인터넷에 의해 보여지지 않는 사설 네트워크를 구성하는 데 유용하게 사용된다. 127로 시작하는 IPv4주소들은 항상 ___로컬 루프백 주소(Local Loopback Address)___ 의미. ->이 주소에 대한 호스트네임이 Localhost.

- 4바이트 각각에 모두 같은 숫자를 사용하는 IPv4주소는 브로드캐스트 주소이다. ex)255.255.255.255 ☞ 브로드캐스트 주소는 일반적으로 로컬 네트워크 안의 노드를 탐색하는 용도로 사용-> 찾고자 하는 서버의 정보를 담은 패킷을 보내고, 해당 서버가 이를 받아 응답한다. 이 응답에는 IP주소와 DNS정보가 포함됨.

## 인터넷
- 수 많은 컴퓨터들이 IP프로토콜을 통해서 대화 가능한 비결정 네트워크 그룹.

- IP 기반 네트워크 중에서 가장 크다.




# 스트림
## 자바에서의 스트림
- 스트림은 동기(Synchronous)로 동작한다. 프로그램이 데이터를 읽거나 쓰기 위해 스트림에 요청하면, 스트림은 다른 작업을 수행하기 전에 데이터를 읽거나 쓸 수 있을 때까지 기다린다.

## 출력 스트림
- 자바 기본 출력 클래스 java.io.OutputStream이고, public class OutputStream을 제공한다.
- OutputStream의 서브클래스는 특정 매체에 데이터를 쓰기 위해 이 메소드를 사용한다. 

- 쓰고자 하는 매체의 종류에 관계없이 사용 가능하다. 자료형이 정해진 메소드(서브클래스)를 반환하는 것이 아니라, 슈퍼클래스인 OutputStream을 반환하도록 선언되어 있다. -> 다형성(Polymorphism)
- OutputStream의 기반 메소드는 write(int var)이다. 이 메소드는 서브클래스에서 목적에 맞는 특정 매체를 다루기 위해 변경할 수 있도록 추상 메소드(abstract method)로 선언되어 있다.
- 한번에 한 바이트씩 출력하는 방식은 매우 비효율적이기 때문에 write와 같은 메소드를 사용하여 메모리에 데이터를 쌓아 두고, 일정 수치에 도달하거나 특정 시간을 초과할 경우 데이터를 전송한다. 이 방식이 훨씬 빠르다.
- 스트림은 네트워크 하드웨어가 아닌 자바 코드 내에서 직접 버퍼링할 수 있다. BufferedOutputStream이나 BufferedWriter를 연결하여 버퍼링이 가능해진다.
- 이러한 버퍼링이 사용되기 때문에 출력 스트림을 사용할 때 플러시(flush)가 중요하다. 출력 스트림은 버퍼가 가득 차지 않았을 때 버퍼 안의 데이터를 전송하지 않고 추가적인 데이터가 올 때까지 기다리는데 서버로부터 응답을 받기 전에 추가로 쓸 데이터가 없다면, 요청은 버퍼에 담긴 채로 전송되지 않기 때문에 결코 서버로부터의 응답은 오지 않을 것이다. 이러한 상황에서 flush() 메소드는 버퍼가 아직 가득 차지 않은 상황에서 강제로 버퍼의 내용을 전송함으로써 이와 같은 데드락 상태를 해제한다.
- 스트림이 버퍼링되는지를 판단하여 플러시하는 것보다 항상 플러시를 하는 것이 좋다.
- 스트림 사용이 끝나면 해당 스트림의 close()메소드를 호출하여 스트림을 닫는다. 출력 스트림을 닫은 후에 스트림에 쓰기를 시도하면 IOException이 발생함.

- 장시간 실행 중인 프로그램에서 스트림을 닫지 않을 경우, 다양한 리소스에서 누수(leak)가 발생한다. 스트림 변수는 유효범위를 고려하여 try블록 바깥에 선언(declare)해야 하고, 초기화(initialize)는 try 블록 안에서 해야 한다.
- 스트림 변수를 닫기 전에 NULL 여부를 검사하여 NullPointerExceptions를 피하도록 한다.

## 입력 스트림
- 기본 입력 클래스는 java.io.InputStream이다.
- InputStream의 서브클래스는 특정 매체로부터 데이터를 읽기 위해 이 메소드를 사용한다.
- InputStream에서도 역시 다형성이 동작하기 때문에 서브클래스에 대한 인식 없이 데이터를 읽을 수 있다.
- InputStream의 기본 메소드 read()는 인자가 없다. 
- 읽을 것이 없는 경우 프로그램의 실행을 중단하고 기다리는 특성 때문에 read() 메소드는 종종 입출력의 속도가 매우 느려질 때가 있다. 속도에 민감한 작업을 처리해야 하는 상황이라면 입출력을 별도의 스레드로 분리하는 것이 좋다.
  
```java
byte[] input = new byte[10];
for(int i=0; i<input.length(); i++) {
    int b = in.read();
    if(b == -1) break;
    input[i] = (byte) b;
}
```
- 위의 코드에서 read() 메소드는 바이트 값만 읽을 수 있지만 int형을 반환한다. 그리고 반환값을 바이트 배열에 저장하기 전에 byte 타입으로 캐스팅한다. 
- read() 메소드의 반환값을 바이트 배열에 저장하기 전에 byte 타입으로 캐스팅한다. int 타입을 바이트 타입으로 캐스팅하면 0~255까지의 부호 없는 바이트가 아닌 -128~127까지 부호 있는 바이트 값이 생성되며, 부호 없는 바이트 값이 필요한 경우 아래 코드과 같이 변환할 수 있다.

```java
int i = (b >= 0) ? b : 256 + b;
```

- 인자를 가진 두 read() 메소드는 배열 크기만큼 읽어 반환을 시도하지만 항상 성공하는 것은 아니다.
  - 데이터를 읽는 동안 네트워크가 단절되는 경우, 읽기에 실패하며 IOException발생.
  - 데이터의 일부만 읽을 수 있는 경우, read() 메소드는 실제로 읽은 바이트 수만을 반환한다. 실제 읽고자 하는 바이트의 크기가 보장되어야 한다면 배열이 찰 떄까지 반복하는 반복문 내에 read 메소드를 위치시켜 문제 해결 가능. -> 네트워크 스트림에서 읽을 때 자주 쓰임.
- 기본 read() 메소드를 포함한 세 가지 read() 메소드는 스트림의 끝에 도달할 경우 -1을 반환한다.
- 아직 읽지 않은 데이터가 남아 있는 상태에서 스트림이 종료된 경우 멀티바이트 read() 메소드는 버퍼를 비울 떄 까지 데이터를 모두 읽어 반환함. -> 다시 read() 메소드를 호출하면 -1을 반환하며, -1이 반환될 경우 어떠한 값도 반환되지 않으며, 배열의 값은 호출 전 상태로 남아있다.
- 