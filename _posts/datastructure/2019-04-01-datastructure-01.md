---
title: "알고리즘 성능 분석"
categories:
  - data structure
tags:
  - Data structure
  - study
  - Theory
  - 공간 복잡도
  - 시간 복잡도
comments:
  - true
---
## 공간 복잡도 & 시간 복잡도
#### Space Complexity & Time Complexity
***

#### 정의
- 공간 복잡도
☞ 프로그램을 실행시켜 완료하는 데 필요로 하는 ___공간의 양___.


  **임의의 프로그램의 총 공간 요구 S(P) = c + Sp(I)**

c = 고정 공간 요구(코드 저장을 위한 공간, 단순 변수, 상수들을 위한 공간)

Sp(I) = 가변 공간 요구(특정 인스턴스 I에 의존하는 크기를 가진 변수가 필요로 하는 공간)

 ※ I는 입출력의 횟수, 크기, 값 등을 의미하며 I값에 따라 S(P)가 변한다. *공간 복잡도를 분서할 때는 보통 가변 공간 요구에 대해서만 관심을 둔다.*

- 시간 복잡도
☞ 프로그램을 실행시켜 완료하는 데 필요한 ___컴퓨터 시간의 양___.

**임의의 프로그램의 총 시간 요구 T(P) = 컴파일 시간 + 실행 시간**

여기서 컴파일 시간은 공간 복잡도의 고정 공간과 유사하게 인스턴스 특성에 의존하지 않는다. *시간 복잡도를 분석할 때는 실행 시간만 염두에 둔다.*

시간 복잡도는 크게 Ω(오메가) 표기법, Θ(세타) 표기법, O(빅오) 표기법이 있는데, Ω(오메가) 표기법은 O(빅오) 표기법과 반대로 f(n)의 하한값(최선의 상황)을 나타낸다. *f(n) ≥ C·g(n), n ≥ n0* 를 만족할 때, f(n) = Ω(g(n))으로 표기한다.

** O(빅오) 표기법은 f(n)의 상한값(최악의 상황)을 나타낸다.**
*f(n) ≤ C·g(n), n ≥ k* 을 만족할 때, f(n) = O(g(n))으로 표기한다.

Θ(세타) 표기법은 가장 정확한 값을 게산할 수 있는 기법이지만, 계산 자체가 어려운 방법이다.
*C1·g(n) ≤ f(n) ≤ C2·g(n), n ≥ n0* 을 만족할 때, f(n) = Θ(g(n))으로 표기한다.


>적은 메모리, 빠른 속도를 최적의 알고리즘이라고 할 수 있지만, 실행속도에 더 초점을 둔다.
>>시간 복잡도에서 중요한 것은 데이터 수가 많아짐에 따른 연산횟수의 증가 정도이다.
>>>하지만, 성능이 좋은 알고리즘은 그렇지 않은 알고리즘에 비해 구현 난이도가 월등이 높다. 데이터 수가 적거나 성능이 중요하지 않은 상황에서는 편의상 후자의 경우를 택하기도 한다.


- #### 대표적인 Big-Oh
*데이터 수의 증가에 따른 연산횟수의 증가 형태*

---
1. O(1) : 상수형 빅-오. 연산횟수가 데이터 수에 상관없이 진행되는 알고리즘. 연산횟수가 고정인 유형의 알고리즘을 대표한다.
_연산이 3번 진행되는 알고리즘이라도 1로 표기한다._

2. O(log n) : 로그형 빅-오. 데이터 수의 증가율에 비해서 연산횟수의 증가율이 훨씬 낮은 알고리즘.

3. O(n) : 선형 빅-오. 데이터 수와 연산횟수가 비례하는 알고리즘.

4. O(n log n) : 선형로그형 빅-오. 연산횟수는 두 배를 조금 넘게 증가하는 알고리즘을 의미한다. 상당수의 알고리즘이 선형로그형에 해당.

5. O(n²) : 이중으로 중첩된 반복문 내에서 연산이 진행되는 알고리즘이다. 그리 바람직하지 못하다.

6. O(n³) : 삼중으로 중첩된 반복문 내에서 연산이 진행되는 알고리즘이다. 적용하기에는 무리가 있다.

7. O(2ⁿ) : 지수형 빅-오. 사용한다는 것 자체가 비현실적이다.

*1~7번까지 성능에 따라 정리하였다.*
![](assets/img/datastructure/tcmp2.jpg)





[^posts]: Footnote test.
