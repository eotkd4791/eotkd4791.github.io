---
title: "JAVA Network Programming 01"
categories:
  - Java
tags:
  - Network
  - Java
comments:
  - true
---

# 스트림
## 자바에서의 스트림
- 스트림은 동기(Synchronous)로 동작한다. 프로그램이 데이터를 읽거나 쓰기 위해 스트림에 요청하면, 스트림은 다른 작업을 수행하기 전에 데이터를 읽거나 쓸 수 있을 때까지 기다린다.

## 출력 스트림
- 자바 기본 출력 클래스 java.io.OutputStream이고, public class OutputStream을 제공한다.
- OutputStream의 서브클래스는 특정 매체에 데이터를 쓰기 위해 이 메소드를 사용한다. 

- 쓰고자 하는 매체의 종류에 관계없이 사용 가능하다. 자료형이 정해진 메소드(서브클래스)를 반환하는 것이 아니라, 슈퍼클래스인 OutputStream을 반환하도록 선언되어 있다. -> 다형성(Polymorphism)

- OutputStream의 기반 메소드는 write(int var)이다. 
  - 이 메소드는 서브클래스에서 목적에 맞는 특정 매체를 다루기 위해 변경할 수 있도록 추상 메소드(abstract method)로 선언되어 있다.

- 한번에 한 바이트씩 출력하는 방식은 매우 비효율적이기 때문에 write와 같은 메소드를 사용하여 메모리에 데이터를 쌓아 두고, 일정 수치에 도달하거나 특정 시간을 초과할 경우 데이터를 전송한다. 이 방식이 훨씬 빠르다.

- 스트림은 네트워크 하드웨어가 아닌 자바 코드 내에서 직접 버퍼링할 수 있다.
  - BufferedOutputStream이나 BufferedWriter를 연결하여 버퍼링이 가능해진다.

- 이러한 버퍼링이 사용되기 때문에 출력 스트림을 사용할 때 플러시(flush)가 중요하다. 출력 스트림은 버퍼가 가득 차지 않았을 때 버퍼 안의 데이터를 전송하지 않고 추가적인 데이터가 올 때까지 기다리는데 서버로부터 응답을 받기 전에 추가로 쓸 데이터가 없다면, 요청은 버퍼에 담긴 채로 전송되지 않기 때문에 결코 서버로부터의 응답은 오지 않을 것이다.
  - 이러한 상황에서 flush() 메소드는 버퍼가 아직 가득 차지 않은 상황에서 강제로 버퍼의 내용을 전송함으로써 이와 같은 데드락 상태를 해제한다.

- 스트림이 버퍼링되는지를 판단하여 플러시하는 것보다 항상 플러시를 하는 것이 좋다.

- 스트림 사용이 끝나면 해당 스트림의 close()메소드를 호출하여 스트림을 닫는다. 
  - 출력 스트림을 닫은 후에 스트림에 쓰기를 시도하면 IOException이 발생함.

- 장시간 실행 중인 프로그램에서 스트림을 닫지 않을 경우, 다양한 리소스에서 누수(leak)가 발생한다. 스트림 변수는 유효범위를 고려하여 try블록 바깥에 선언(declare)해야 하고, 초기화(initialize)는 try 블록 안에서 해야 한다.

- 스트림 변수를 닫기 전에 NULL 여부를 검사하여 NullPointerExceptions를 피하도록 한다.

## 입력 스트림
- 기본 입력 클래스는 java.io.InputStream이다.

- InputStream의 서브클래스는 특정 매체로부터 데이터를 읽기 위해 이 메소드를 사용한다.

- InputStream에서도 역시 다형성이 동작하기 때문에 서브클래스에 대한 인식 없이 데이터를 읽을 수 있다.

- InputStream의 기본 메소드 read()는 인자가 없다. 

- 읽을 것이 없는 경우 프로그램의 실행을 중단하고 기다리는 특성 때문에 read() 메소드는 종종 입출력의 속도가 매우 느려질 때가 있다. 속도에 민감한 작업을 처리해야 하는 상황이라면 입출력을 별도의 스레드로 분리하는 것이 좋다.
  
```java
byte[] input = new byte[10];
for(int i=0; i<input.length(); i++) {
    int b = in.read();
    if(b == -1) break;
    input[i] = (byte) b;
}
```
- 위의 코드에서 read() 메소드는 바이트 값만 읽을 수 있지만 int형을 반환한다. 그리고 반환값을 바이트 배열에 저장하기 전에 byte 타입으로 캐스팅한다. 

- read() 메소드의 반환값을 바이트 배열에 저장하기 전에 byte 타입으로 캐스팅한다. int 타입을 바이트 타입으로 캐스팅하면 0~255까지의 부호 없는 바이트가 아닌 -128~127까지 부호 있는 바이트 값이 생성되며, 부호 없는 바이트 값이 필요한 경우 아래 코드과 같이 변환할 수 있다.

```java
int i = (b >= 0) ? b : 256 + b;
```

- 인자를 가진 두 read() 메소드는 배열 크기만큼 읽어 반환을 시도하지만 항상 성공하는 것은 아니다.
  - 데이터를 읽는 동안 네트워크가 단절되는 경우, 읽기에 실패하며 IOException발생.
  - 데이터의 일부만 읽을 수 있는 경우, read() 메소드는 실제로 읽은 바이트 수만을 반환한다. 실제 읽고자 하는 바이트의 크기가 보장되어야 한다면 배열이 찰 떄까지 반복하는 반복문 내에 read 메소드를 위치시켜 문제 해결 가능. -> 네트워크 스트림에서 읽을 때 자주 쓰임.

- 기본 read() 메소드를 포함한 세 가지 read() 메소드는 스트림의 끝에 도달할 경우 -1을 반환한다.

- 아직 읽지 않은 데이터가 남아 있는 상태에서 스트림이 종료된 경우 멀티바이트 read() 메소드는 버퍼를 비울 떄 까지 데이터를 모두 읽어 반환함.
  - 다시 read() 메소드를 호출하면 -1을 반환하며, -1이 반환될 경우 어떠한 값도 반환되지 않는다. 배열의 값은 호출 전 상태로 남아있다.