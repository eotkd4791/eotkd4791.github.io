---
title: "Database01"
categories:
  - Theory
tags:
  - Theory
  - Database

comments:
  - true
---

## Database01
---
### 데이터베이스 개념
```
  * 데이터베이스 정의
    * 통합 데이터 Integrated Data
    * 저장 데이터 Stored Data
    * 운영 데이터 Operational Data
    * 공유 데이터 Shared Data
```

```
  * 데이터베이스 특징
    * 실시간 접근성 Real Time Accessibility
    * 계속적인 진화 Continuous Evolution
    * 동시 공유 Concurrent Sharing
    * 내용에 의한 참조 Content Reference
    * 데이터의 논리적, 물리적 독립성 Independence
```

```
  * 데이터베이스 시스템
    * 정의
    * 구성 요소
```
```
  * 데이터 언어 Data Language

    * 데이터 정의어 Data Definition Language (DDL)
      * 구조, 데이터 형식, 접근 방식의 구축이나 변경
      * CREATE DROP ALTER
      * 기능
      * 데이터베이스의 논리적, 물리적 구조를 정의 및 변경
      * 스키마(Schema)에 사용되는 제약 조건 정의
      * 데이터의 물리적 순서 규정

    * 데이터 조작어 Data Manipulation Language
      * 응용 프로그램과 데베관리시스템 간의 인터페이스
      * 검색 삽입 삭제 갱신
      * INSERT DELETE UPDATE
      * 형태
        - 절차적 데이터 조작어
        - 비절차적 데이터 조작어

    * 데이터 제어어 Data Control Language
      * 보안, 권한제어, 무결성, 회복, 병행제어
      * REVOKE GRANT
```

```
  * 데이터베이스 사용자

    * 데이터 베이스 관리자(DBA: DataBase Administrator)
      * DDL,DCL로 데베를 정의, 제어하는 사람이나 그룹
      * 상당한 지식 보유해야함
      * 설계 관리 운영 통제하며, 시스템감시와 성능 분석

    * 데이터 관리자(Data Administrator)
      * 기업 또는 조직 전반의 데이터 관리를 총괄.
      * 중앙 집중적인 계획 수립 및 통제

    * 데이터 설계자(Data Architect)
      * 데이터 구조를 체계적으로 정의

    * 응용 프로그래머(Application Programmer)
      * DML을 삽입하여 데베에 접근하는 사람.

    * 일반 사용자(End User)
      * 질의어(Query Language)를 통해 데이터베이스 관리 시스템에 접근하는 사람.
```    
---
### 데이터베이스 관리 시스템(DBMS)
```
* 데이터베이스 관리 시스템(DataBase Management System)
  * 중복성, 종속성 문제 해결.
    * 데이터 종속성으로 인한 문제점
      * 저장 방법이나 접근 방법 변경 시 응용프로그램도 변경 해야함.
    * 데이터 중복성으로 인한 문제점
      * 일관성, 보안 수준, 정확성, 무결성 유지 어려움.
```
```
* 데이터베이스 관리 시스템 필수 기능
  * 정의 기능 Definition Facility
    * 데이터 타입과 구조, 저장 시 제약조건 등을 명시
  * 조작 기능 Manipulation Facility
    * 데이터 접근 기능(검색, 삽입, 삭제, 갱신) 명시
  * 제어 기능 Control Facility
    * 데이터의 정확성, 안전성 유지를 위해 무결성, 보안 및 권한 검사, 병행 제어 등 명시
```
```
* DBMS 장단점

  * 장점
    * 데이터의 논리적, 물리적 독립성이 보장
    * 공동 이용가능
    * 표준화
    * 무결성 유지
    * 실시간 처리
    * 중복 줄일 수 있다.
    * 통합하여 관리 가능
    * 일관성 유지
    * 보안 유지
    * 항상 최신 데이터 유wl

   * 단점
    * 데이터데이스 전문가 부족
    * 대용량 디스크로의 집중적인 접근으로 과부하 발생
    * 전산화 비용 증가
    * 데이터 백업과 회복이 어렵다
    * 시스템이 복잡해진다.
```
---
### 스키마
```
* 스키마(Schema)의 개념
 * 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)
 * 개체(Entity), 속성(Attribute), 관계(Relationship) 및 제약 조건 등에 관해 전반적으로 정의
 * 사용자 관점에 따라
    * 외부 스키마(External Schema)
    * 내부 스키마(Internal Schema)
    * 개념 스키마(Conceptual Schema)
```
```
* 스키마의 특징
   * 데이터의 구조적 특성
   * 데이터사전(Data Dictionary)에 저장된다.
   * 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어짐
   * 시간에 따라 불변인 특성 지님
   * 데이터의 논리적 단위에 명칭을 부여, 그 의미를 서술
```
```
* 데이터 사전(Data Dictionary)
 - 데이터 사전은 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정보를 유지, 관리하는 시스템
 - 시스템 카탈로그

* 메타 데이터(Meta Data)
  * 데이터에 관한 데이터
  * 실제 저장되는 데이터는 아니지만, 저장되는 데이터와
  직,간접적으로 관계가 있는 정보를 제공하는 데이터

  * 메타 데이터 포멧
    * MARC(Machine Readable Cataloging)
      - 목록 레코드를 식별하여 축적, 유통할 수 있도록 코드화한 메타 데이터

    * DC(Dublin Core)
      - 네트워크 환경에서 각종 전자 정보를 기술하는 메타 데이터

    * ONIX(ONline Information eXchange)
      - 유통에 관한 통계와 체계적인 정보를 취급함으로써 정상적인 유통 및 관리를 위한 메타 데이터

    * MODS(Metadata Object Description Schema)
      - 디지털 도서관의 범용 서지 정보 표준 메타 데이터로서 MARC, DC, ONIX 등을 절충하여 상호 운용성과 정밀성을 모두 만족시킴

# 메타 데이터의 상호운용성을 확보하기 위한 방법
  - 자원을 하나의 표준적인 메타 데이터로 표현하는 방법
  - 다양한 메타 데이터형식과 기술 구조를 인정, 상호 매핑을 통해 해결하는 방법
  - MDR(Meta Data Registry)에 의한 해결 방법
    + MDR : 메타 데이터 등록,인증을 통해 유지,관리하고, 명세를 공유하는 레지    
```

```
* 스키마의 3계층
  * 외부 스키마
    - 사용자나 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것이다.
    - 외부 스키마는 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Sub Schema)라고도 함.
    - 하나의 DBMS당 여러 외부 스키마 존재가능, 하나의 스키마를 여러 프로그램이나 사용자에 의해 공유될 수 있다.
    - 외부 스키마는 동일한 데베에 대해 서로 다른 관점 정의 허용

  * 개념 스키마
    - 개체 간의 관계, 제약조건, 데베의 접근 권한, 보안 정책 및 무결성 규정에 관한 명세 정의 한 것.
    - 데베의 전체적인 논리적 구조 -> 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 데베 명세, #오직 하나만 존재#
    - 단순히 스키마라고 하면 개념 스키마 의미
    - 기관이나 조직의 관점에서 데베를 정의한 것.
    - 데베 관리자에 의해 작성

  * 내부 스키마
    - 데베의 물리적 구조 정의
    - 물리적 저장장치 관점, 하나만 존재
    - 개념 스키마의 물리적 저장 구조에 대한 정의
    - 시스템 프로그래머나 설계자가 보는 관점
```
---
### 데베 설계

```
* 데베 설계 개념
  - 데베 스키마를 개발하는 과정
  1. 요구 조건 분석 Requirement Analysis
  2. 개념적 설계 Conceptual Design
  3. 논리적 설계 Logical Design
  4. 물리적 절계 Physical Design
  5. 데베 구현 Database Implementation
  - 데베 구조에 치중하는 데베 중심 설계(Data-driven)와 데이터 처리,응용에 치중하는 처리 중심(Processing-driven)을 병행
```

```
* 요구 조건 분석
  - 용도 파악
  1. 개체, 속성, 관계, 제약 조건 등과 같은 정적 정보 구조
  2. 트랜잭션의 유형, 실행 빈도와 같은 동적 정적 데이터베이스 처리 요구 조건
  3. 기관의 경영 목표 및 정책, 규정과 같은 범기관적 제약조건에 대한 요구 조건.
```
```
* 개념적 설계
  - 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해, 통신을 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정.
  1. 개념 스키마 모델링, 트랜잭션 모델링을 병행하여 수행.
  2. 데이터의 조직과 표현에 치중하기 때문에 데이터 중심 설계라 한다.
  3. 요구 조건 분석의 결과로 나온 명세를 기반으로 데이터 모델에서의 데이터 구조(개념 스키마)를 기술하는 과정
  4. 요구 조건 분석 결과로부터 개념적 데이터 모델을 유도하는 기본원리는 추상화.
  5. 추상화: 복잡한 것들을 단순화.
    - 집단화 : 여러 속성들을 그룹지어 하나의 개체로 만든다.
    - 일반화 : 공통 성질을 가진 여러 부류의 개체들을 보다 일반적이고 포괄적인 개체로 만든다.
  6. 트랜잭션 모델링에서는 트랜잭션의 입,출력과 기능적 형태를 정의하는 트랜잭션 명세를 작성.
    - 입,출력 데이터, 그리고 제어의 기능적 흐름을 명세함으로써 트랜잭션을 개념적이고 시스템 독립적으로 정의.
```

```
* 논리적 설계
  - 인터페이스 정의
  - 현실 세계에서 발생하는 데이터 형태를 컴퓨터가 이해할 수 있는 논리적 데이터 구조로 변환시키는 과정
  1. 논리적 데이터 모델에서의 데이터구조(논리 스키마) 설계
  2. 논리적 설계를 위해서는 먼저 특정 데베 관리 시스템을 선정해야한다.
    * 소프트웨어 획득 비용, 유지 비용
    * 데베 구축, 전환 비용, 교육, 운용 비용 등
  3. 관계형 DBMS를 선장한 경우, 개념적 설계에서 기술한 ER도형을 정형적인 규칙에 따라 릴레이션 스키마로 변환한다.
  4. 더욱 좋은 릴레이션 스키마를 만들기 위하여 정규화(Normalization) 과정을 수행한다.
  5. 개념적 설계에서 기술한 트랜잭션 명세로부터 트랜잭션의 전체적인 골격을 개발하고 인터페이스를 정의.
```

```
* 물리적 설계
  - 주어진 응용 프로그램에 대한 성능 향상을 위해 데이터베이스 팡리에 대한 특정한 저장 구조와 접근경로를 결정하는 과정
  1. 효율적이고 구현 가능한 물리적 데이터베이스 구조(물리 스키마)
  2. 물리적 설계에는 저장 구조를 위한 레코드의 양식, 순서, 저장 공간 등과 접근 경로를 위한 인덱싱, 클러스터링, 해싱 등의 설계가 포함
  3. 특정 DBMS뿐만 아니라 특정 하드웨어 및 운영체제의 특성도 고려해야한다.
  4. 효과적인 물리적 설계를 위해 데이터베이스 트랜잭션을 요청해서 응답을 얻기까지의 응ㄴ답 시간, 데이터베이스 트랜잭션을 요청해서 응답을 덥기 까지의 응답시간, 데이터 베이스 파일과 접근 경로 구조에 대한 저장 공간의 효율성, 일정 단위 시간 동안 처리되는 트랜잭션 평균 수인 트랜잭션 처리도(Throughput) 등을 고려해야함.
  5. 논리적 설계에서 기술한 트랜잭션의 인터페이스로부터 상세 트랜잭션을 정의한다.
```

```
* 데베 구현
  - 데베 구현은 데베를 실제로 구축하는 과정이다.
  1. 선정된 DBMS의 DDL로 기술된 명령문을 실행시켜 데베 스키마와 데베 파일을 생성, 필요할 경우 데베 데이터를 입력.
  2. 데베 구현 단계에서 응용 프로그래머에 의해 상세 트랜잭션이 실행 트랜잭션으로 구현된다. DML로 기술된 명령문을 가지는 프로그램 코드가 작성된다. 
```
---
### ER(Entity Relationship)모델

```
* ER 모델
  - ER 모델은 개념적 데이터 모델의 가장 대표적인 것, 1976년 피터 첸에 의해 제안.
  - 개체, 속성, 관계 등에 대하여 용이하게 표현할 수 있는 ER 도형(ERD; Entity Relationship Diagram) 정의
```

```
* ER 도형
  1. 개체 타입 - 사각형
  2. 관계 타입 - 마름모
  3. 속성 - 타원
  4. 기본키(primary key) 속성 - 타원 안에 밑줄
  5. 개체 타입간의 연관성 - 마름모로 개체들 연결
  6. 직선 - 개체 타입과 속성을 연결
  7. ISA관계 - 역삼각형(ISA)
    * 서로 구별되는 여러 하위 개체로 나누어질 수 있습니다.
    * ISA 간계는 이러한 상위 개체와 하위 개체 간의 관계를 의미함.
    * ex) 학생은 재학생, 휴학생, 졸업생으로 분류
  8. 다중값 속성 - 이중 타원
  9. 유도 속성 - 점선 타원
  10. 복합 속성 - 타원과 직선의 집합.
  11. 기본키는 유일하게 식별되는 속성으로 설정해야함.
```

```
* 개체 및 개체 타입
    - 현실 세계의 객체로서 유형 또는 무형의 정보 대상으로 존재하며 서로 구별될 수  있는 것을 뜻하고 개체의 특성을 나타내는 속성을 갖는다.
    - 하나의 개체를 개체 어커런스(Entity Occurrence) 또는 개체 인스턴스(Entity Instance)라 하고, 개체 어커런스들의 집합에 대한 공통 특성들을 갖는 개체 클라스를 개체 타입이라고 함.
    - ex) 이름과 학과명을 갖는 '교수'는 개체 타입이고, 이름이 '홍길동'이며 학과가 '컴공'인 교수 데이터는 개체 어커런스가 됨.
    - 유형 개체: 교수,학생,자동차,집 등과 같이 실제로 존재하는 것.
    - 무형 개체: 인사, 급여, 수강, 진료 등과 같이 개념적인 개체.
```

```
* 관계 및 관계 타입
  - 2개 이상의 개체 사이에 존재하는 연관성.
  - 관계 타입은 같은 관계들의 집합 또는 틀
  1. 관계는 관계에 참여하는 개체 타입의 개수에 대한 차수(Degree)와 관계에 참여하는 개체 어커런스의 개수에 대한 대응 카디널리티(Mapping Cardinality)를 갖음.
  2. 차수에 따른 관계의 종류
    - 단항(Unary) 관계 : 관계에 참여하고 있는 개체 타입이 1개
    - 이항(Binary) 관계 : 2개
    - 삼항(Ternary) 관계 : 3
    - n항(n-ary) : n

  * 어커런스 : 테이블에 들어있는 레코드.
  3. 대응 카디널리티에 따른 관계의 종류
    - 1:1 관계 : 관계에 참여하고 있는 두 개체 타입이 모두 하나씩의 개체 어커런스를 갖는 관계
      - ex)교수와 과목 간의 관계(한 과목은 한명의 교수에 의해서만 강의가 이루어진다.)
    - 1:N 관계 : 한 개체 타입은 여러개의 개체 어커런스를 가질 수 있고, 다른 한 개체 타입은 하나의 개체 어커런스를 가짐.
      - ex) 교수와 학생. 한 교수는 여러명의 학생을 지도, 한 학생은 한명의 교수에게만 지도 받음.
    - N : M 관계 : 두 개체 타입 모두 여러 개의 개체 어커런스를 가질 수 있다.
      - ex) 학생과 과목. 한 학생이 여러 개의 과목 등록 가능. 여러 학생이 한 과목 등록 가능.
  4. ISA 관계
     - 같은 속성을 갖는 여러 개체들을 하나의 상위 개체로 결합할 수 있으며, 특정 개체는 서로 구별되는 여러 하위 개체로 나누어 질 수 있음.
     - 상위 개체 멤버가 하나의 하위 개체에만 포함될 때 disjoint - 표현 방법: ISA삼각형 옆에 글씨쓴다.
     - 상위 개체 멤버가 어려 하위 개체에 포함될 때 overlapping - 표현 방법: ISA삼각형 옆에 글씨쓴다.
     - 상위 개체 멤버가 하위 개체에 속할 때 total - 표현 방법 ISA로 들어오는 선 이중으로 연결선 표시
     - 속하지 않을 때 partial - 표현 방법 단일 선.
```

```
* 속성 Attribute
  - 속성은 개체의 특성이나 상태를 기술한 것이다. 관계 역시 개체와 마찬가지로 속성을 가질 수 있다.
  1. 속성이 가질 수 있는 모든 가능한 값들의 집합- 도메인(Domain) 
  2. 모든 개체 타입은 그 개체를 유일하게 식별해주는 기본키에 속하는 속성을 포함.
  3. 더 이상 나눌 수 없는 속성 - 단순 속성(Simple Attribute)
  4. 나눌 수 있는 속성 - 복합 속성(Composite Attribute)
```
---
### 관계형 데이터 모델
  관계형 데이터 모델은 데이터를 테이블(table) 또는 릴레이션(relation)의 구조로 표현되는 논리적 데이터 모델

```
* 관계형 데이터 구조: 릴레이션
  - 관계형 데이터 모델에서 데이터를 원자값(Atomic Value)으로 갖는 이차원의 테이블로 표현. =릴레이션
  - 물리적인 저장 구조를 나타내는 것이 아닌 논리적인 구조이므로 다양한 정렬 기준을 통하여 릴레이션 표현 가능
  - 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성됨.
  - 릴레이션은 열(Column)을 속성(Attribute)이라고 하고, 행(Row)을 튜플(Tuple)이라고 한다.
  - 릴레이션에서 하나의 애트리뷰터가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합을 도메인이라고 한다.
  - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용된다.
```

```
* ER 모델을 관계형 데이터 모델로 변환
  - 개념적 데이터 모델인 ER 모델을 논리적 데이터 모델인 릴레이션 스키마로 변환하는 것으로, 매핑 룰(Mapping Rule)이라고도 한다.
  - ER 도형에서의 개체와 관계는 관계형 데이터 모델에서의 개체 릴레이션과 관계 릴레이션으로 변환하여 표현.
  - 속성은 열(Column)으로, 식별자는 기본키로 표현하고, 릴레이션 간의 관계는 기본 키와 이를 참조하는 외래키(Foreign Key)로 표현한다.
  * 개체 A,B와 관계 Y로 이루어진 ER 모델을 관계형 데이터 모델에서의 릴레이션 스키마로 변환하는 과정
    - 개체 A,B는 각각 독립적인 릴레이션 A,B로 표현된다. 또한, ER 도형에서의 각 개체의 속성들은 각 릴레이션의 속성들로 정의되고, 기본키는 밑줄을 그어 표시한다.
    - 관계 Y가 1:1 관계이면, 릴레이션 A의 기본키를 릴레이션 B의 외래키로 추가하거나 그 반대로 표현한다.
    - Y가 1:N 관계이면, 릴레이션  A의 기본키를 릴레이션 B의 외래키로 추가하여 표현한다.
    - 관계 Y가 N:M관계이면, A,B의 기본키를 모두 포함한 별도의 릴레이션으로 표현한다. 이때 생성된 별도의 릴레이션을 교차 릴레이션(Intersection Relation) 또는 교차 엔티티(Intersection Entity)라고 표현한다.
  * 상위 개체 A와 하위 개체B, C가 ISA관계로 이루어진 ER 모델을 릴레이션 스키말 변환하는 방법
    1. A 릴레이션의 기본키를 B와 C릴레이션의 외래키로 추가하여 표현. A,B,C세개의 릴레이션이 생성
    2. A가 가지고 있는 속성과 B,C가 가지고 있는 속성을 각자 결합하여 표현한다. 즉 A 속성을 포함하고 있는 B,C 두개의 릴레이션이 생성.
  
  * 릴레이션 스키마의 다른 표현
    1. 속성만 기록한 도형으로 표기
    2. 속성에 자료의 형과 크기를 표시한 도형으로 표기
    3. 정보 공학적 도형을 이용하여 표기
       1. 논리 개체 관계도(외래키 표기시 FK표기)
       2. 물리 개체 관계도 
          1. 정보 공학적 표기 기호
             1. 기본 기호
                1. | 필수(Mandatory)
                2. o 선택적(Optional)
                3. < 다중(Multiple)
             2. 관계의 표현
                1. 1:1 - 양쪽에 반드시 1개씩 존재
                2. 1:0 or 1:1 - 왼쪽에는 반드시 1개, 오른쪽에는 없거나 1개 존재
                3. 1:N - 왼쪽에는 반드시 1개, 오른쪽에는 반드시 여러개 존재
                4. 1:1 or 1:N - 왼쪽에는 반드시 1개, 오른쪽에는 1개 or 여러개 존재
                5. 1:0 or 1:1 or 1:N - 왼쪽에는 반드시 1개, 오른쪽에는 0개나 1개나 여러개 존재
   
  * 식별관계 /비식별 관계
    1. 식별 관계(Identifying)
     - 개체 A,B 사이의 관계에서 A 개체의 기본키가 B 개체의 외래키이면서 동시에 기본키가 되는 관계
     - B 개체의 존재 여부가 A 개체의 존재 여부에 의존적인 경우에 발생하며, ER 도형에서 식별 관계는 실선으로 표시
    
    2. 비식별 관계(Non-identifying)
     - 개체 A,B사이의 관계에서 A 개체의 기본키가 B 개체의 비기본키 영역에서 외래키가 되는 관계를 말함.
     - B 개체의 존재 여부는 A 개체의 존재여부와 관계 없이 존재.
     - 일반적으로 두 개체는 비식별 관계로 존재하는 경우가 많으며, ER 도형에서 점선으로 표시
  
  * 테이블 정의서
    * 테이블에 대한 자세한 설명과 컬럼에 대하여 정의한 문서, 논리적 데이터 설계 시에 클래스 다이어그램, 시퀀스 다이어그램 등의 문서와 같이 산출.
    * 표준 양식이 정해져있지 않지만, 일반적으로 시스템명, 테이블ID, 테이블명, 작성일 및 작성자, 컬럼ID, 컬럼명, 데이터 타입, 길이, 키 정보, NULL값 허용 여부 등 테이블에 대한 구체적인 내용을 포함.
    * 관계형 데이터모델에서는 테이블 정의서 외에 뷰, 인덱스 등에 대한 정의서도 작성.
```

---
### 키의 개념 및 종류

키: 데베에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성.

```
* 슈퍼키(Super Key)
  * 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키.
  * 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
  * 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성(Unigue)은 만족하지만, 최소성(Minimality)은 만족하지 않는다.

* 후보키(Candidate Key)
  * 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
  * 유일성과 최소성 모두 만족
  * (학번, 과목명)과 같이 2개 이상의 필드를 조합하여 만든 키를 복합키(Composite Key)라고 한다.

* 기본키(Primary Key)
  * 후보키 중에서 특별히 선정된 키로 중복된 값을 가질 수 없다.
  * 후보키의 성질을 갖는다.(유일성과 최소성) 튜플을 식별하기 위해 반드시 필요한 키
  * NULL값 가질 수 없다. 튜플에서 기본키로 설정된 값에 NULL값이 있으면 안된다.

* 대체키(Alternate Key)
  * 대체키 = 후보키 - 기본키

* 외래키(Foreign Key)
  * 다른 릴레이션의 기본키를 참조한느 속성 또는 속성들의 집합
  * 릴레이션 간의 관계를 표현할 때 사용
  * 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 한다.
  * 참조 릴레이션의 기본키와 동일한 키속성을 가진다.
```

---
### 무결성(Integrity)

```
* 무결성의 개념
  * 데베에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미
  * 무결성 제약 조건(Constraint)은 데베에 저장된 데이터의 정확성을 보장하기 위해 정확하지 않은 데이터가 데베 내에 저장되는 것을 방지하기 위한 제약조건을 말함.

* 무결성의 종류
  *  NULL 무결성: 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정
  *  고유 (Unique) 무결성: 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정
  *  도메인 (Domain) 무결성: 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
  *  키 (Key) 무결성: 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정
  *  관계 (Relationship) 무결성: 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정
  *  참조 (Referential) 무결성: 외래키 값은 NULL 이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정
  *  개체 (Entity) 무결성: 기본 릴레이션의 기본키를 구성하는 어떤 속성도 NULL일 수 없다는 규정
```

---
### 관계대수(Relational Algebra)

```
* 관계대수의 개념
  * 관계형 데베에서 우너하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 언어
  * 하나 또는 두 개의 릴레이션을 입력으로 받아들여 결과로서 새로운 릴레이션을 생성해내는 연산들의 집합
  * 관계대수의 연산에는 기본 연산인 SELECT, PROJECT, JOIN, DIVISION 등과 집합 연산인 UNION, DIFFERENCE, INTERSECTION, CARTESIAN PRODUCT 등이 있다.

* 순수 관계 연산자
  * SELECT
    * 릴레이션에 존재하는 튜플들 중에서 특정 조건을 만족하는 튜플들의 부분집합을 구하여 새로운 릴레이션을 만든다.
    * 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다.
    * SELECT 연산의 기호는 σ이다.
    * σ<조건>(릴레이션R)
    * 조건에서는 ≠,≤,≥,＜,＞,＝ 등의 기호를 사용한 비교 연산이 허용되며, AND(∧),OR(∨) ,NOT(ㄱ) 등의 논리 연산자를 사용하여 여러 조건을 하나의 조건으로 결합시킬 수도 있다.
  * PROJECT
    * 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만든다. 단, 연산 결과에 중복이 발생하면 중복이 제거된다.
    * 릴레이션에서 열에 해당하는 속성을 추출하는 것이므로 수직 연산이라고도 한다.
    * PROJECT 연산의 기호는 π이다.
    * π<속성 리스트>(릴레이션R)
  * JOIN
    * 공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만듦
    * JOIN 연산의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같다.
    * JOIN 연산의 결과는 CARTESIAN PRODUCT 연산을 수행한 다음 SELECT 연산을 수행한 것과 같다.
    * JOIN 연산의 기호는 ▷◁
    * R ▷◁(JOIN 조건)S  (R,S는 릴레이션.)
    * 비교 연산자를 θ로 일반화하여 θ로 표현될 수 있는 조인을 세타 조인(θ-join, Theta-JOIN)이라고 한다.
    * JOIN 조건이 '='일 때 동일한 속성이 2번 나타나게 되는데, 이 중 중복된 속성을 제거하여 같은 속성은 한번만 나타나게 하는 연산을 자연 조인(NATURAL JOIN)이라 한다.
  * DIVISION
    * 두 릴레이션R(X)와 S(Y)에 대해 Y⊆X이고 X-Y=Z라고 하면, R(X)와 R(Z,Y)는 동일한 표현.
    * 릴레이션 R(Z,Y)에 대한 S(Y)의 DIVISION 연산은 S(Y)의 모든 튜플에 연관되어 있는 R(Z)의 튜플을 선택하는 것
    * R[속성r ÷ 속성s]S
      - 속성r은 릴레이션R의 속성, 속성s는 릴레이션S의 속성, 속성r과 속성s는 동일 속성 값을 가지는 속성이어야 한다.
```

```
* 일반 집합 연산자
  * 수학적 집합 이론에서 사용하는 연산자로서 릴레이션 연산에도 그대로 적용할 수 있다.
  * 집합 연산 중 UNION, DIFFERENCE, INTERSECTION을 처리하기 위해서는 합병 조건을 만족해야함.
  * 두 릴레이션 R과 S가 있을 때 각 집합 연산의 특징
    * 합집합(UNION)
      * 연산자
        * 합집합(UNION) 연산 기호 U
        * 두 릴레이션에 존재하는 튜플의 합집합을 구하는 연산
        * 결과로 생성된 릴레이션에서 중복되는 튜플은 제거된다.
        * R U S = {t|t∈R ∨ t∈S}
          * t는 릴레이션 R 또는 S에 존재하는 튜플.
      * 카디널리티
        * |R U S| ≤ |R| + |S|
        * 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않다.
    * 교집합(INTERSECTION)
      * 연산자
        * 교집합(INTERSECTION) 연산 기호 ∩
        * 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
        * R ∩ S = {t|t∈R ∧ t∈S}
          * t는 릴레이션 R과 S에 동시에 존재하는 튜플
      * 카디널리티
        * |R ∩ S| ≤ Min{|R|,|S|}
        * 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다.
```