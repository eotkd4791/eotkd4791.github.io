---
title: 비트 마스킹 (Bit Masking)
categories:
  - Algorithm
tags:
  - Bit Masking
comments:
  - true
read_time: false
toc: true
toc_sticky: true
---

## 비트 마스크

컴퓨터는 이진수 기반의 비트 연산을 수행한다. 비트는 이러한 연산에서 사용되는 데이터의 최소 단위이다. 비트마스크는 문제를 푸는 열쇠인 알고리즘이라기 보다는 열쇠를 더 잘 사용하기 위한 하나의 테크닉이다.

비트 연산을 이용하면 성능과 메모리 효율 면에서 이득을 볼 수 있다. 하나의 int형 변수가 있다고 가정해보자. int형 변수는 32 bit (4 Byte)만큼의 크기를 가지는데 하나의 비트당 하나의 원소를 저장하여 특정 원소의 존재 유무를 빠르게 파악할 수 있다. 비트 마스크가 어떻게 쓰이는지 예제를 통해서 알아보자.

## 비트 연산시 주의할 점

비트 연산자는 다른 연산자보다 우선 순위가 낮기 때문에 괄호로 묶어서 계산해 주어야 한다. 또한 int형의 변수는 32 bit의 크기를 갖는데,
32번 이상의 시프트 연산을 하면 오버플로우가 발생한다.

```cpp
long long a = x;

a & (1 << b);
```

위의 코드를 보면 1을 b만큼 시프트 연산하는 부분에서 1은 부호가 있는 int형 상수로 취급되기 때문에 b가 32 이상이라면 오버플로우가 발생한다. 따라서 1 뒤에 부호 없는 64 bit 정수임을 명시하는 ull이라는 접미사를 써줘야한다.

부호가 있는 데이터 타입의 경우 가장 높은 자릿수는 부호를 의미하지만, 부호가 없는 데이터 타입의 경우에는 모든 자릿수가 값을 나타낸다.

## 비트 연산자를 이용하여 값 찾기

AND 연산자를 이용하면 특정 값의 유무를 알아낼 수 있다. 먼저 b라는 원소가 a에 존재하는지를 알아보는 식을 써보면 아래와 같다.

```cpp
a & (1 << b);
```

1을 b만큼 왼쪽으로 시프트 연산을 하면 존재 유무를 검사할 자리에 도달한다. 그 후에 AND연산을 통해서 해당 자리에 b가 존재하면 해당 자리의 값이 1일 것이므로 계산 결과는 0보다 큰 값이 나오게 된다. 반면에 해당 자리에 b가 존재하지 않는다면 0이 나오게 된다.

## 값 추가하기

OR 연산자를 이용하면 특정 값을 추가할 수 있다.

```cpp
a |= (1 << b);
```

값을 추가하고 싶은 위치까지 시프트 연산을 수행한 후, OR 연산을 해준다.

## 값 삭제하기

특정 위치의 값을 삭제하는 것은 아래와 같은 식으로 나타낼 수 있다고 생각할 수 있지만, 해당 위치에 값이 존재하지 않을 때에는 잘못된 결과가 출력될 수 있다.

```cpp
a -= (1 << p);
```

따라서 해당 위치에 값의 존재 여부를 모른다고 가정하고 진행해야 한다. 값이 없다면 그대로 두고, 값이 존재한다면 삭제를 해주는 방식으로 코드를 작성해야한다. 아래 코드를 보자.

```cpp
a &= ~(1 << p);
```

NOT연산자를 통해서 반전을 시킨 후, AND 연산을 수행한다면 값이 존재하는 경우 a의 해당 위치가 1, b는 0에서 반전이 되었으므로 0이 되어 AND 연산 결과로 0이 출력된다. 따라서 값의 삭제가 이루어진 것이다. 반면에 값이 존재하는 경우에는 a의 해당 위치가 0, b도 0이기 때문에 AND 연산 결과로 0이 출력된다.

## 값 토글하기

특정 위치의 값이 0이면 1로, 1이면 0으로 바꾸는 토글 연산이다. 토글 연산은 XOR 연산을 통해서 할 수 있는데, 먼저 XOR 연산의 특징을 알아보자.

|   a   |   b   | 결과  |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   1   |   0   |   1   |
| **0** | **1** | **1** |
| **1** | **1** | **0** |

XOR 연산 결과를 나타낸 표에서 굵게 표시된 부분을 보면 b의 값이 1일 때의 연산 결과가 다르게 출력되는 것을 알 수 있다. XOR 연산의 이러한 특성을 이용해서 값을 토글 시킬 수 있다.

```cpp
a ^= (1<<p);
```

## 집합 끼리의 연산

```cpp
A | B  // A와 B의 합집합

A & B  // A와 B의 교집합

A & ~B // A ∩ Bc  =>  A - B

A ^ B // A와 B 중 하나에만 포함된 원소들의 집합
```

## 집합의 크기 구하는 연산

집합에 포함된 원소의 갯수를 구하는 연산은 재귀 함수 호출을 이용하면 된다. 십진수에서 자릿수를 분리해서 계산하는 연산과 상당히 비슷하다.

```cpp
int setSize(int x)
{
  if(x == 0) return 0;

  return x % 2 + setSize(x / 2);
}
```

20을 예로 들어보자. 20의 이진수는 10100이다. 재귀 호출을 할 때 인자로 들어온 x값을 2로 나누어 호출한다. 즉, 첫번째 함수 호출에서 10100을 인자로써 호출했다면, 두번째 호출에서는 1010이 호출되는 것이다. 재귀 호출을 하면서 이진수 자리가 1인 경우에 (인자값 % 2) 연산의 결과가 1이 나오기 때문에 이진수 자리에서 1의 갯수를 찾을 수 있게 되는 것이다.

## 집합에서 가장 작은 원소 찾기

이진수 자리에서 1이 등장하는 가장 작은 자릿수를 찾는 방법은 2의 보수와의 AND 연산을 통해서 구해낼 수 있다. 2의 보수를 취하면 처음으로 1이 등장한 자릿수의 뒤의 모든 자릿수는 0이 되는 특성을 이용하면 된다.

```cpp
a = (b & -b);
```

2의 보수와 AND 연산을 하게되면 처음으로 1이 등장하는 자리만 1이 되기 때문에 집합에서 가장 작은 원소를 쉽게 찾을 수 있다.

## 가장 작은 원소 지우기

위에서 "집합에서 가장 작은 원소 찾기"를 했다. 이번에는 최소 원소를 삭제하는 연산에 대해 알아보자. 최소 원소 삭제 연산은 생각보다 간단하다. 최소 원소를 찾을 집합에서 1을 빼주고 AND 연산을 하면 된다.

```cpp
a &= (a - 1);
```

a에서 1을 빼면, 최소 원소는 0이 되고 해당 자릿수보다 작은 자릿수는 1로 세팅된다. 이 값과 원래의 집합을 AND 연산하면 최소 원소 부터 그 이후의 자릿수가 모두 0으로 출력된다.

## 모든 부분 집합 순회하기

```cpp
for(int sub = set; sub; sub = ((sub - 1) & set)) {}
```

sub가 0이 될 때까지 반복문을 수행한다. 반복문이 거듭되면서 sub는 최소 원소가 지워진 값으로 갱신 된다.

## 비트 마스크를 이용하여 에라토스테네스 체 구현하기

```cpp
int n;

unsigned char sieve[(MAX_N + 7) / 8];

bool isPrime(int k) { //k가 소수인지 확인하는 함수
  return  sieve[k >> 3] & (1 << (k & 7));
}
// k >> 3 == k / 8 하나의 index마다 8개의 숫자가 들어갈 수 있기 때문에..
// k & 7 == k % 8

void setComposite(int k) { //소수가 아닌 수를 제외하는 함수
  sieve[k >> 3] &= ~(1 << (k & 7));
}

void err() {
  memset(sieve, 255, sizeof(sieve)); //char 자료형은 1 Byte = 8 bit이다. 따라서 2^8 - 1의 값인 255로 배열을 초기화 해준다.
  setComposite(0);
  setComposite(1); // 0과 1은 소수가 아니므로 제외시킨다.

  int sqrtn = (int) sqrt(n));
  for(itn i = 2; i <= sqrtn; i++) {
    if(isPrime(i)) {
      for(int j = i * 2; j <= n; j++) {
        setComposite(j); //소수의 배수들을 지운다.
      }
    }
  }
}
```

<br><br>

> 참고 자료<br> >[Sangwoo Blog](https://sangwoo0727.github.io/algorithm/Algorithm-Bitmask/)<br>
> 구종만, 프로그래밍 대회에서 배우는 알고리즘 문제해결전략(인사이트)
