---
title: "BOJ10775 공항"
categories:
  - Algorithm
tags:
  - Union-Find
  - Disjoint_Set
---

☞[문제 보기](https://www.acmicpc.net/problem/10775) 
 
---

### 문제 설명
- 1~G개의 게이트가 있고, P개의 비행기가 순서대로 도킹한다.
- 이미 도킹한 게이트는 더이상 도킹할 수 없다.
- i번째 비행기 gi는 1~gi까지의 게이트에 도킹할 수 있다.
- 만약 도킹할 수 있는 게이트가 없다면, 그 이후의 비행기는 더이상 공항에 오지 않는다.
- 게이트의 수 G는 최대 십만, 비행기의 수 P도 최대 십만이다. 따라서 2중 for문으로 풀어나간다면 시간초과가 될 것이다.

### keypoint
- gi가 도킹할 수 있는 가장 큰 수부터 내림차순으로 도킹을 해야 최대값이 나올 수 있다.

  ```
	G=4, P=4일때, gi = 3,2,1,1이라고 했을 때,
	도킹할 수 있는 게이트 번호가 가장 큰 값부터 차례대로 진행한다면 
	3,2,1 게이트에 도킹할 수 있으므로 최대값은 3이 된다.
	그게 아니라면 최대값 3보다 작은 값이 나온다.
  ```

- 게이트에 도킹이 된다면 그 앞번 게이트를 가리키도록 parent배열에 기록해놓았고, 트리가 합쳐지면 경로 압축 최적화 방법을 통해서 하나의 트리에 연결된 노드들이 모두 루트를 가리키도록 저장해둔다.

- 게이트를 노드라고 가정하면 도킹이 완료되지 않은 노드의 부모노드는 자기자신이 되고, 그게 아니라면 해당 노드보다 앞 번호가 쓰여진 노드가 해당 노드의 부모노드로 저장되어 있을 것이다.

- 다음 비행기의 번호가 이미 도킹된 게이트의 번호와 같다면 앞번의 게이트를 확인하여야 하는데, 이 부분을 트리로 구현한다.

 ```
    G 1 2 3 [4 5 6] 
	4,5,6번이 도킹되어 있다고 가정한다.
    이 상황에서 4,5,6은 하나의 트리로 연결되어 있으며, 루트는 4가된다. 
	따라서 비행기의 번호가 4,5,6중 하나가 들어와도 
	루트를 그대로 참조하여 도킹을 진행하면 
	보다 효율적인 시간에 해결할 수 있다.
 ```

---

### 풀이
- 주석 참고.

---

### 고찰
아이디어를 찾아내는 것이 정말 어려웠다. 특히 유니온 파인드 자료구조를 적용하는 과정이 매우 어려웠다. 머리 아픈 문제였다.
그래도 재미있는 문제였다. 유니온파인드 적용에 익숙해지도록 반복숙달을 해야겠다.

---

### 소스코드

```cpp
#include <iostream>
using namespace std;

const int INF = 100000 + 1;
int G, P, gi, cnt;
bool flag;
int parent[INF];

int find(int v)
{
	if (v == parent[v])
		return v;
	return parent[v] = find(parent[v]);//경로 압축
}

void merge(int u, int v)
{
	int ru = find(u);
	int rv = find(v);
	parent[u] = v;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> G;
	for (int g = 1; g <= G; g++)
		parent[g] = g;
	cin >> P;

	for (int i = 0; i < P; i++)
	{
		cin >> gi;
		if (flag) //더이상 도킹할 게이트가 없다면 그대로 종료한다.
			continue;

		int tmp = find(gi);
		if (tmp != 0)
		{
			merge(tmp, tmp - 1);
			cnt++;
		}
		else 
        //루트가 0인 트리에 연결되어 있다면 더이상 도킹할 게이트가
        //없다는 것을 의미한다. 따라서 flag를 true로 바꿔준다.
			flag = true;
	}
	cout << cnt << '\n';
	return 0;
}
```
