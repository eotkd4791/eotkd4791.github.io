---
title: "Binary Search Tree"
categories:
  - Algorithm
tags:
  - Algorithm
  - Tree
  - Binary Search Tree
  - Theory
comments:
  - true
---



## 이진 탐색 트리 Binary Search Tree
이진 탐색 트리에 대한 기본 연산은 트리의 높이에 비례하는 시간에 수행된다.
n개의 노드로 이루어진 완전 이진 탐색 트리(Complete Binary Search Tree)에 대해 이런 연산들은 최악의 경우, Θ(lg n)시간에 실행된다. 하지만 n개의 노드가 선형으로 연결된 모양인 트리인 경우,평균 Θ(n) 시간에 수행된다.

### 특성
>**" x가 이진 탐색 트리의 한 노드일 때, y가 x의 왼쪽 서브 트리의 한 노드면 y.key ≤ x.key를 만족한다. 그리고 y가 x의 오른쪽 서브 트리의 한 노드면 y.key ≥ x.key를 만족한다. "**

---

- 트리 순회 Tree Walk
  1. 중위 트리 순회(inorder tree walk)
     - 왼쪽 서브 트리 -> 루트 -> 오른쪽 서브트리 순서로 순회
  2. 전위 트리 순회(preorder tree walk)
     - 루트 -> 왼쪽 서브 트리 -> 오른쪽 서브 트리 순서로 순회
  3. 후위 트리 순회(postorder tree walk)
     - 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트 순서로 순회

  4. 트리 순회 시, 트리의 각 노드에 대해 재귀적으로 왼쪽 한 번, 오른쪽 한 번으로 총 두 번씩 재귀호출을 하기 때문에 n개의 노드로 이루어진 이진 탐색 트리를 순회하는 데 Θ(n) 시간이 걸린다.
     - **Ω(n) ≤ T(n) ≤ O(n) -> T(n) = Θ(n)**

#### <가정> 
트리를 순회하는 함수 Tree_Walk가 n개의 노드로 이루어진 서브 트리를 도는 데 Θ(n)의 시간이 걸린다.
서브 트리의 루트=x.

#### <증명> 
Tree_Walk를 n 개의 노드로 이루어진 서브트리의 루트에 대해서 호출했을 때 걸리는 시간을 T(n)이라고 할 때, Tree_Walk는 모든 노드를 방문하기 때문에 T(n) = Ω(n)이다.
T(n)이 O(n)과 같다는 것만 증명하면 T(n) = Θ(n)이 증명된다.

서브 트리의 어떤 노드를 방문하면서 NULL인지 아닌지 확인하는 상수 시간 c가 소요된다.

트리의 왼쪽 서브트리는 k개의 노드를 가지고 있고, 오른쪾 서브트리는 n-k-1개의 노드를 가지고 있다.(전체 트리의 루트 제외).
따라서 트리 순회를 하는 데에 필요한 시간 T(n) ≤ T(k) + T(n-k-1) + d이다. 이때, 상수 d는 재귀호출(스택에 쌓을 때)할 때 필요한 시간을 말한다.

T(n) = O(n)을면 T(n) ≤ (c+d)n + c로 치환하여 계산하면, n=0일 때 (c+d)*0 + c = c = T(0)이므로 T(n) ≤ (c+d)n + c는 만족한다.

T(n) ≤ T(k) + T(n-k-1) + d
     ≤ ((c+d)k+c)+((c+d)(n-k-1)+c)+d
     = (c+d)n+c-(c+d)+c+d
     =(c+d)n+c


### 질의 Query
Query란 전처리된 데이터에 접근하여 연산을 수행하는 것.

### 1. 탐색
   1. 특정 원소 k 찾기
      - 루트부터 탐색하면서 찾고자 하는 값 k가 만나는 노드에 저장되어 있는 값보다 작은 경우에 왼쪽 서브 트리로, 큰 경우에 오른쪽 서브 트리로 탐색을 진행하게 된다.

    2. 최대 원소, 최소 원소 찾기
       - NIL을 만날 때 까지 루트에서 왼쪽 자식을 계속 따라가면 마지막으로 만나는 값이 최소 원소.
       - NIL을 만날 때 까지 루트에서 오른쪽 자식을 계속 따라가면 마지막으로 만나는 값이 최대 원소.

        **최소, 최대 원소는 트리의 하나의 단순 경로에 존재한다.**
        >단순 경로란 같은 정점을 한번만 지나는 경로를 뜻하며, 이진 탐색 트리에서 특정 원소가 있어야할 자리에 없다면 그 값은 해당 트리 내에 존재하지 않는 값이다. 즉, 존재하거나 존재하지 않거나 둘중 하나만 존재한다.

    3. 직전 원소, 직후 원소 찾기
       - 직전 원소
         1. 정의 : 이진 탐색 트리에서 한 노드를 x라고 했을 때 x보다 작은 값이 저장되어 있는 모든 노드 중에서 가장 큰 값이 저장되어 있는 값을 직전 원소라고 한다.
         2. 탐색 방법
            - 기준 노드의 왼쪽 서브 트리가 있다면, 해당 서브 트리에서 가장 오른쪽 노드이 직전 원소가 된다.
            - 서브트리가 없다면, 부모 노드를 따라 올라가면서 탐색하는 노드가 부모 노드의 오른쪽 자식 노드일 때 그 부모 노드는 직전 원소가 된다.


       - 직후 원소
         1. 정의 : 이진 탐색 트리에서 한 노드를 x라고 했을 때 x보다 큰 값이 저장되어 있는 모든 노드 중에서 가장 작은 값이 저장되어 있는 값을 직후 원소라고 한다.
         2. 탐색 방법
            - 기준 노드의 오른쪽 서브 트리가 있다면, 해당 서브 트리의 가장 왼쪽 자식이 직후 원소가 된다.
            - 서브트리가 없다면, 부모 노드를 따라 올라가면서 탐색하는 노드가 부모 노드의 왼쪽 자식 노드일 때 그 부모 노드는 직후 원소가 된다.
  

>참고문헌<br>
INTRODUCTION TO ALGORITHMS 3rd Edition<br>CLRS지음, 문병로,심규석,이충세 옮김
