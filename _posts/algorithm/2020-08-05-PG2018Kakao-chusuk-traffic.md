---
title: '프로그래머스 추석트래픽(JS)'
categories:
  - Algorithm
tags:
  - Algorithm
  - Scheduling
comments:
  - true
---

[추석트래픽](https://programmers.co.kr/learn/courses/30/lessons/17676)

## 풀이

1번 풀이

먼저 문자열 파싱 부분을 살펴보겠다. 우선순위 큐(이하 pq)를 활용한 스케쥴링 알고리즘으로 풀이하였다. 먼저 문자열을 파싱하고, 소수점에서 발생하는 오차를 줄이기 위해 1000을 곱해주었다. 또한 처리시간은 요청 완료 시간을 포함하므로, arr배열에 push할 때, 요청 발생 시간에서 1을 빼주었다. 이러한 과정을 통해 arr배열 내부의 값은 길이가 2인 배열로 채워진다. 이때 0번째 인덱스에는 요청 발생시간, 1번째 인덱스에는 요청 완료시간이 저장된다.

다음으로 알고리즘 부분을 살펴보겠다. 요청 발생시간을 기준으로 오름차순 정렬을 해준다. time은 기준이 되는 시점으로부터 1초 간격 이내에 발생한 요청인지를 확인할 때 필요한 변수이다. 선언시, 가장 먼저 발생한 요청시간으로 초기화한다.

요청 발생시간을 기준 오름차순으로 정렬된 배열을 순회하면서 각 시점당 time을 이용하여 1초 이내에 존재하는지 확인한다. 1초 이내에 존재하면 해당 요청의 완료시간을 pq에 삽입하고, 기준이 되는 범위를 벗어난다면, pq에서 가장 우선순위가 높은(가장 값이 작은) 값을 기준으로 1초 범위를 벗어나는 값을 모두 pq에서 삭제한다. 이러한 과정을 반복하면서 pq의 길이가 가장 큰 순간을 찾으면 된다.

코드를 통해 자세히 살펴보자.

```js
function solution(lines) {
  let ans = 0;
  const arr = [];

  /* 주어진 문자열 파싱
  ------------------------------------------*/

  lines.forEach((v) => {
    const date = v.split(' ');
    const time = date[1].split(':');
    const mil = parseFloat(date[2].substr(0, date[2].length - 1)) * 1000;

    let s = 3600;
    let sec = 0;
    time.forEach((t) => {
      sec += parseFloat(t) * s * 1000;
      s /= 60;
    });
    arr.push([sec - mil + 1, sec]); // [ 요청 발생 시간, 요청에 대한 응답 완료시간  ]
  });

  /* 알고리즘 부분
  ------------------------------------------*/
  arr.sort((a, b) => (a[0] < b[0] ? -1 : 1)); // 요청 발생시간 기준 오름차순 정렬.

  const pq = []; //우선순위 큐

  let time = arr[0][0]; // 1초 범위 계산시 기준

  for (let v of arr) {
    // 요청의 발생, 완료 시간이 담긴 배열 순회.

    if (time + 999 < v[0]) {
      //1초 범위를 벗어난다면 해당 조건문에 입장, 1초 범위 내에 있다면 조건문을 수행하지 않고 pq에 완료시간 삽입.

      while (pq[0] + 999 < v[0] && pq.length > 0) pq.shift();
      //pq의 값중 우선순위가 가장 높은 값(응답 완료시간이 가장 높은 값)을 기준으로 1초 범위 내에 벗어나는 값들을 제거한다.

      time = pq.length === 0 ? v[0] : pq[0];
      // pq 내부에 값이 남아있다면 그 값들중 가장 우선순위가 높은 값으로, pq가 비어있다면 현 시점 바라보고 있는 요청의 발생시간을 삽입한다.
    }
    const newIdx = pq.findIndex((i) => i > v[1]);
    // 우선순위 큐에 값을 삽입하기 위해서 위치를 찾는다.

    pq.splice(newIdx === -1 ? pq.length : newIdx, 0, v[1]);
    // 값을 삽입한다.

    ans = Math.max(ans, pq.length);
  }
  return ans;
}
```
