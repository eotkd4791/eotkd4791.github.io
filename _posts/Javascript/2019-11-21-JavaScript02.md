---
title: "JavaScript 함수"
categories:
  - JavaScript
tags:
  - JavaScript
read_time: false
toc: true
toc_sticky: true
---


## 호이스팅(Hoisting) 

"끌어 올리다"라는 의미로 변수 및 함수의 '선언'을 끌어올리는 것이다. 호이스팅이 발생하는 이유는 자바스크립트 인터프리터가
코드의 라인 순서와 관계 없이 함수 선언식과 변수를 위한 메모리 공간을 먼저 확보하는 특성을 가지고 있기 때문이다.

```js
console.log(a());
console.log(b());
console.log(c());

function a() {
  return 'a';
}
var b = function bb() { //#2
  return 'bb';
}
var c = function() {  //#3
  return 'c';
}

/////////////////////////////////////////////////////////////////////////////////
/*  
  호이스팅 후에 아래와 같은 코드처럼 변수,함수 선언문의 위치가 변경된 형태로 실행한다.

  1. 함수 선언문은 통째로 올라간다.
  
  2. 반면에 함수 표현식은 선언"만" 올린다.

  3. 할당은 해당사항이 아니다.

  4. 함수 선언문은 그 자체로 하나의 선언이지만, #2, #3에서는 선언과 할당이 한 문장 내에서 이루어진다.
  -> 분리가 가능함.
*/
/////////////////////////////////////////////////////////////////////////////////

function a() {
  return 'a';
}
var b;////**
var c;////**
console.log(a());
console.log(b());
console.log(c());

b = function bb() {
  return 'bb';
}
c = function() {
  return 'c';
}
```

자바스크립트 엔진은 코드를 실행하기 전 단계로 코드 전반에 걸쳐서 선언된 내용이 있는지를 훑어보고 발견하는 즉시 변수, 함수 선언한 것을 상부로 끌어올린다.

## 함수 표현식

```js
var c = function() {
  return 'c';
//1. 변수 c를 선언하고, 익명함수를 선언한다.
//2. 변수 c에 익명함수를 할당한다. -> 함수 표현식
}
```

>함수 표현식의 개념 : "선언한 함수를 변수에 할당한다."


함수표현식과 함수 선언문의 차이는 "할당 여부"에 있다. 할당을 하지 않으면 전체가 호이스팅의 대상이되고 할당이 되면 함수는 
그자리에 남아있고, 변수만 호이스팅을 하게된다. 호이스팅이 되는지 안되는지에 따라 실무에서 엄청난 차이를 만들어낸다.

```js
function sum(a, b) {//1번 함수
  return a + ' + ' + b  ' = ' + (a + b);
}
sum(1,2);

/* ... 중략 ...*/

function sum(a, b) {//2번 함수
  return a + b;
}
sum(3, 4);
```

코드의 길이가 긴 상황에서 같은 이름의 함수가 다른 내용을 가지고 있을 때 호이스팅에 의해서 두 함수 선언문 모두 맨 위로 

끌어올려지고 캐스캐이딩(cascading) 원칙에 의해서 나중에 호이스팅된 함수가 먼저 호이스팅된 함수를 덮어 씌우게 된다. 

그 결과로 1번 함수의 내용이 2번 함수에 의해 변경되고 어떤 함수를 호출해도 값만 나오는 함수(2번 함수)가 된다.


## 함수 선언문과 함수 표현식의 차이

```js
//함수 선언문 function declaration
function a() {
  return 'a';
}

//기명 함수표현식  named function expression
var b = function bb() {
  return 'bb';
}

//(익명) 함수표현식 (unnamed/annoymous) function expression
var c = function() {
  return 'c';
}
```

모던 브라우저 대부분이 익명 함수 표현식의 경우 네임 프로퍼티에 값을 부여하지 않았기 때문에 디버깅할 때 기명 함수 표현식을 쓰는 것의 이점이 분명히 존재했다. 어떤 함수에서 에러가 발생하면 콘솔에서 에러가 발생한 함수의 이름을 출력해주기 때문에 
해당 함수의 이름을 찾아서 에러를 수정하기가 용이했다. 반면에, 최근의 브라우저들은 함수명이 비어있을 경우에 함수명을 
자동으로 네임 프로퍼티에 할당하기 때문에 이제는 기명 함수 표현식을 쓰는 경우가 거의 없다.


함수 선언문은 "모든 코드는 위에서부터 아래로 읽어내려가면서 실행한다."는 상식에서 벗어나 있어서 가독성 면에서 
굉장히 좋지 않다. 1인 개발 시에 어디서 선언하든 언제나 실행된다는 편리함이 존재하지만, 다른 개발자와 협업시에 
코드 읽기가 힘들어지고 생산성을 저해하는 요인이 된다. 따라서 함수 선언문을 사용하는 것보다 무조건 함수 표현식을 사용하는 
것이 안전하고 예측가능한 소스가 되기 때문에 권장된다. ES6에서는 이러한 예측 가능성과 성능 측면에서의 이유 때문에 "function"이라는 키워드 자체를 쓰지 않아도 되게끔 만들었다.

<br>
<br>
<br>

>정재남님의 인프런 자바스크립트 강의